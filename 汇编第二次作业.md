## 汇编语言 第二次作业

**2018302070001  沈思源**

### 一、填空题

1. "后进先出"(LIFO)或者叫做"先进后出"
2. 立即数寻址方式
3. PUSH SI
4. LEA AX, A
5. EXTRN，PUBLIC
6. AX
7. 7FFFH; SF= 0, CF= 1, OF= 1
8. 8001H; SF=1, CF=0, OF= 0
9. 带符号数比较条件转移指令 ： 

```asm
P: ....
   ....
   ....
   CMP AX,BX
   JNL P
```

10. AX , DX
 	11. 5F3FH，5230H
 	12. IP ; CS,IP
  13. 22636H , 2263CH



### 二、选择题

1. A
2. D  需要对一些不确定的存储属性需要显式指定,BX和BP寄存器不允许出现在同一个[ ]内，SI和DI也不能同时出现。
3. C ;偏移地址为 09CH, 说明是短跳转指令, 指令长度为 2 bytes; 相对寻址的跳转指令中的偏移是以该跳转指令的下一条指令为基的,0135H+02H+9CH        **???**
4. B
5. C
6. C
7. D
8. C; 12AB0H+00ABH+100H-2
9. D ;寄存器相对寻址
10. A



### 三、改错题

![image-20200502113305357](assets/image-20200502113305357.png)

![image-20200502114754041](assets/image-20200502114754041.png)



1. 错误，CMP指令和SUB指令操作相同，双操作数指令中可以使用立即数寻址，但是立即数只能位于源操作数字段，这里位于OPD目的操作数字段，故错误.     CMP AX,0

2. 错误，这里是不确定的存储属性，需要显式指定，[BX]表示的是用BX寄存器值做地址，必须指定这个数据的类型. INC BYTE PTR[BX]或者对BX加1为INC BX

3. 错误，同样是没有指定存储属性,且**内存到内存不合法**,源操作数和目的操作数不能同时为存储器操作数，即存储单元之间不能用MOV指令直接传送.可以使用寄存器进行中转.

   ```asm
   MOV AX, [SI]
   MOV [DI],AX
   ```

4. 类型不明确. AND AL, BYTE PTR[DX],直接操作寄存器位数不匹配错误

5. 功能执行不正确.既然是CX与有符号数进行比较，条件跳转指令也需要用有符号数比较转移指令，而不是无符号比较转移指令

   CMP CX,-10

   JL L

6. 出栈数据应该是一个16位(字)或者32位(双字)的数据，而AH是8位寄存器. POP AX

7. 如果DATA是前面说明过的数据段，那么MOV指令不允许在两个存储单元之间直接传送数据，也不允许在两个段寄存器之间传送信息。

   如果DATA是一个立即数数据，立即数是不允许直接送段寄存器DS的

   MOV AX,DATA

   MOV DS,AX

8. 单操作数指令不允许使用立即数寻址方式.  

   MOV CX,300

   DIV CX

9. **LEA OPD,OPS**指令要求OPD是16/32位的通用寄存器，不能用M主存储器

10. 单操作数指令不能直接使用立即数.

    MOV CL,30H

    MUL CL



### 四、分析题

![image-20200502121348242](assets/image-20200502121348242.png)

| 变量名 | 偏移地址 | 存储单元数据 |
| ------ | -------- | ------------ |
| A      | 000AH    | 'a'          |
|        | 000BH    | '3'          |
|        | 000CH    | 61H（'a'）   |
|        | 000DH    | 00H          |
|        | 000EH    | 62H  ('b')   |
|        | 000FH    | 00H          |
|        | 0010H    | 'b'          |
|        | 0011H    | 'a'          |
|        | 0012H    | 11H          |
|        | 0013H    | 22H          |
| B      | 0014H    | 09H          |
|        | 0015H    | 09H          |
|        | 0016H    | 'A'          |
|        | 0017H    | 'B'          |
|        | 0018H    | 09H          |
|        | 0019H    | 09H          |
|        | 001AH    | 'A'          |
|        | 001BH    | 'B'          |
| E      | 001CH    | 11H          |
|        | 001DH    | 22H          |
|        | 001EH    | 33H          |
|        | 001FH    | 44H          |
|        | 0020H    | 08H          |
|        | 0021H    | 00H          |
|        | 0022H    | 00H          |
|        | 0023H    | 00H          |
|        | 0024H    | 20H          |
|        | 0025H    | 00H          |
|        | 0026H    | 00H          |
|        | 0027H    | 00H          |
|        |          |              |
|        |          |              |

![image-20200502153206284](assets/image-20200502153206284.png)

1. 执行LDS SI,E后，EA=E=0028H, (EA)->SI,(EA+2)->DS

   因此 (SI)=(EA)=2211H ,(DS)=4433H

 2. 执行指令LEA SI,D-2将D-2 EA->SI,   (SI)= 220FH        **???**

 3. 执行LEA SI,A后，(SI)=EA_A=0010H

    执行MOV AX,2[SI]后，(AX)=(2+SI)=(0012H)=0061H='a'

    

![image-20200502155945646](assets/image-20200502155945646.png)

 4. 执行指令LEA SI,A后，(SI)=0010H

    执行指令LEA SI,4[SI]后，EA=4+SI=0014H, (SI)=0014H



### 五、阅读下列程序段，回答问题

1.

```asm
MOV DX,X+2	;P高位->DX
MOV AX,X	;P低位->AX
ADD,AX,X	;2P低位->AX
ADC DX,X+2	;2P高位+来自低位相加的进位CF->DX
CMP DX,Y+2	;2P高位 COMPARE Q高位;高位有符号判断

JL L2
JG L1

CMP AX,Y	;低位无符号判断

JBE L2

L1:	MOV AX,1
	JMP EXIT
L2:	MOV AX,2
EXIT:

```

2.

```asm
OR BX,BX
JNS L1
	MOV DL '-'
	MOV AH,2
	INT 21H
	NEG BX
L1:CALL OUTBX16  ;将BX的无符号二进制数以16进制方式输出
```

![image-20200502163020569](assets/image-20200502163020569.png)



(a):	运行前(BX)=7FF8H=0111 1111 1111 1000进行**或运算**后，符号位SF=0(正数)，结果为正则转移至L1，调用子程序，输出:7FF8H

(b):    运行前(BX)=9FF8H=1001 1111 1111 1000进行**或运算**后，符号位SF=1(负数)，不跳转

​		  '-' -> DL

​		  2号调用，将DL中的字符输出至屏幕上

​		  对(BX)求补 -BX->BX ;BX=0110 0000 0000 0111+1=0110 0000 0000 1000=6008H

​		  输出：-6008H



### 六、分析以下程序段的功能

1、

```asm
    MOV AH,10	
    LEA DX,L1	;取L1的偏移地址->DX
    INT 21H		;调用缓冲区多字符键盘输入 (L1+1存输入不含回车的字符数量,L1+2始存串)
    LEA DX,L2	;取L2的偏移地址->DX	
    INT 21H
    MOV CL,L1+1	;CL存入输入字符串的长度
    CMP CL,L2+1	;
    JNZ N		;两者不相等跳转N
    LEA SI,L1+2	;L1+2处的偏移地址->SI
    LEA DI,L2+2	;L2+2处的偏移地址->DI
    MOV CH,0	;CH置0
    CLD			;CLD即告诉程序SI，DI向前移动
    REPZ CMPSE	;REPE/REPZ表示在CX不为0时，且ZF＝1重复执行后面的串处理指令SCAS或CMPS:
    			;((SI)) - ((DI))两内存单元的内容相减根据比较结果置条件标志位：相等 ZF=1，不等 				  ;ZF=0
    JNZ N
    MOV BX,0
    JMP R
N:	MOV BX,0FFFFH	;BX所有位置1
R:	INC DI			;DI=DI+1
```

获取用户输入的一串字符，存在缓冲区L1中，与L2指向的程序原有字符串进行比较，若两者不完全相同，则置BX为0FFFFH，否则置BX为0



2、

```asm
DATA SEGMENT
BUF DB 'add ax,bx sub cx,10 mov 1234h END $'
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DATA,SS:STACK
BEGIN:
		MOV AX,DATA
		MOV DS,AX
		LEA BX,BUF	;将BUF的EA->BX
		MOV DL,[BX]	;将当前BUF的字节->DL
LOPA:	CMP DL, '$'	;判断该字节数据是否是'$'
		JE EXIT		;是'$'跳转至EXIT
		CMP DL,'a'	;不是再比较是不是'a'
		JB N		;如果比a小跳转N
		CMP DL,'z'	
		JA N		;比z大也跳转N
		SUB DL,20H	;DL的字节数据-20H
   N:	MOV AH,2	
   		INT 21H		;2号调用;显示输出DL的字符
   		INC BX		;BX=BX+1
   		JMP LOPA	;跳转回LOPA
EXIT:	MOV AH,4CH	;DOS正常结束
		INT 21H
CODE ENDS
	END BEGIN
   
```

作用:将BUF指向的存储区存储的字符串的小写字母转换为大写，输出最后的英文字母全为大写形式的字符串



### 七、定义以下宏指令

1. 将X单元中的ASCII码转换为16进制数，结果送Y单元

   ```ASM
   ;要求ASCII码字母大写，字符集合{0-9，A-F}
   TRANSFORM 	MACRO X,Y
   			PUSH DL
   			PUSH DI
   			MOV DI,0
        LOPA:	MOV DL,X[DI]
   			CMP DL,'$'
   			JE EXIT
   			CMP DL 'A'
   			JB N
   			SUB DL,37H
   			JMP R
   		N:	SUB DL,30H
   		R:	MOV Y[DI],DL
   			INC DI
   			JMP LOPA
   	 EXIT:	POP DI
   	 		POP DL
               
   ```

2. 将A缓冲区的N个字/字节送到B缓冲区

   ```asm
   ;FALG==1传送字，FLAG==0传送字节
   BUFMOV MACRO A,B,N,FLAG
   	CMP FLAG,1
   	JZ L1
   	LEA SI,A
   	LEA DI,B
   	CLD
   	MOV CX,N
   	REP MOVSB
   	JMP EXIT
   
   L1:	LEA SI,A
   	LEA DI,B
   	CLD
   	MOV CX,N
   	REP MOVSW
   EXIT:
   	ENDM
   ```
   
   

### 八、定义以下子程序

1. 求N个字之和

```asm
SUM PROC
	PUSH DI
	PUSH BX
	PUSH SI
	XOR BX,BX
	XOR AX,AX
	XOR DX,DX
	XOR DI,DI
	
L1:	CMP DI,CX
	JNL EXIT
	MOV BX,[SI]
	ADD SI,2
	ADC AX,BX
	JC L2
	INC DI
	JMP L1
L2:	ADD DX,CF
	INC DI
	JMP L1
EXIT:POP SI
	 POP BX
	 POP DI
SUM ENDP	
```

2.

在BUF缓冲区内造出有符号数的最大数

```asm
FINDMAX PROC
	PUSH SI
	PUSH BX
    PUSH DI
    XOR DI,DI
    XOR BX,BX
    MOV AX,[SI]
    ADD SI,2
    INC DI
L1:    
    CMP DI,CX
    JNL EXIT
    MOV BX,[SI]
    ADD SI,2
    INC DI
    CMP AX,BX
    JL L2
    JMP L1
L2:	MOV AX,BX
	JMP L1
EXIT: POP DI
	  POP BX
	  POP SI
FINDMAX ENDP
```





