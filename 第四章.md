## 第四章

**2018302070001沈思源**

#### 4.2

![image-20200413155447062](assets/image-20200413155447062.png)

**解**

汇编语言中语句行名字项表示的规定如下:

字母：A-Z,a-z

数字：0-9

专用字符：**?** , **· **，**@** , **_** , **$ **

除去数字外,所有的字符都可以放在源语句的第一个位置，且不可以使用保留字。如果用了 · ,则必须是第一个字符，且长度<=31个字符.



在宏汇编语言中所有变量名、标号名、记录名、指令助记符和寄存器名等统称符号.

|                             正确                             |
| :----------------------------------------------------------: |
|    ASMB,@PROG,C1995,INPUT,JOW,HIGHT,LOW,LOOP,MOV,IN,MOVE,    |
| AX,LEA,DISPLAY,OUTUF,CR_LF,M_DWORD,PUSHM,INPUT,OUTPUT,DATA_AREA |
|                          **不正确**                          |
|                     x*y, Out-Buf, IN/OUT                     |
|                             [BX]                             |

#### 4.3

![image-20200413162442000](assets/image-20200413162442000.png)

![image-20200413162458505](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200413162458505.png)

**解**

首先，根据缩进和变量的定义，所有定义的内存单元都是在唯一的变量**STRING**指向的数据区中存储，除了**MOV**指令外，这里其余的都是伪指令，不产生机器码。

而指令的长度判断可参考:https://blog.csdn.net/Apelpoo/article/details/51870154

**STRING DB 'Pentium.ASM'**

采用DB定义，一个单位一字节(Byte)

因此占有 11个字节

**COUNTS= $-STRING**  该行变量COUNTS等价于EQU不占有内存空间

​				**DB  'AB','A','B'** 采用字节定义,占据4个字节 AB=4142H(ASCII码一个字符表示一个8位数字)

​				**DW '89','AB'** 采用字定义，一个字2字节可以存储两个字符,因此占据2字4字节

**LEN DW 80 DUP(80H)**  定义80个字，每个字数据项内容是80H，占据160字节

**COUNTL EQU LENGTH LEN** LENGTH用于计算元素个数，因此LENGTH LEN为80，COUNTL不占据内存

​				**DB 10 DUP(5DUP(?),'T',6)**, 10*(5+1+1)=70,占据70个字节

**M_DWOR DD 'AB'**     	DD双字定义，占据4字节

​				**ORG $+10**		跳过10个字节

​				**MOV AL,9**        本指令涉及立即数，AL又是一字节，因此占据2字节

​										   共占据16个字节



#### 4.11

![image-20200413170251748](assets/image-20200413170251748.png)

**解**

**MOV BX,M**

表示将操作数M的数据值传送给BX寄存器，执行后(BX)=(M)

**LEA BX,M**

表示将M的EA传送给BX，EA是段内偏移地址或者叫做有效地址，只有16位



**LEA EBX ARRAYD[EBX+ESI]**表示取二维数组的对应对某行某列的一个数据项的EA传送给EBX

**MOV EBX OFFSET ARRAYED[EBX+ESI]**使用了OFFSET(取偏移地址EA的运算符)，**但是**，使用了复杂的地址表达式，不能够用OFFSET来取EA，因为汇编阶段不能够计算出寄存器内容的值形成EA，因此错误



#### 4.13

![image-20200413171312232](assets/image-20200413171312232.png)

```
MOV CL,4
SAL BX,CL

MOV CL,8
SHR SI,CL
```



#### 4.14

![image-20200413171925423](assets/image-20200413171925423.png)

```
PUSH AX
LEA DX,PROMPT
MOV AH,9
INT 21H
POP AX

PUSH AX
LEA DX,ARRAY
MOV AH,10
INT 21H
POP AX

PUSH AX
MOV DL,'$'
MOV AH,2
INT 21H
POP AX
```

#### 4.17

```ASM
;--------------
;IO LIB
;--------------
INOUT MACRO X,Y
	LEA DX,X
	MOV AH,Y
	INT 21H
	ENDM
	
;-------------
;INPUT.ASM
;-------------
.586
INCLUDE IOLIB.LIB
EXTRN BUF:BYTE
PUBLIC GETINPUT
CODES SEGMENT USE16 PARA PUBLIC 'CODE'
	  ASSUME  CS:CODES,FS:SEG BUF
GETINPUT PROC FAR
	MOV AX,SEG BUF
	MOV FS,AX
	INOUT  FS:BUF,10
	RET
GETINPUT ENDP
CODES ENDS
	  END
	  
;-------------
;OUTPUT.ASM
;-------------
.586
INCLUDE IOLIB.LIB
EXTRN BUF:BYTE
PUBLIC DISPLAY
CODES SEGMENT USE16 PARA PUBLIC 'CODE'
	  ASSUME  CS:CODES,ES:SEG BUF
DISPLAY PROC FAR
	MOV AX,SEG BUF
	MOV ES,AX
	INOUT	ES:BUF+2,9
	RET
DISPLAY ENDP
CODES ENDS
	  END
	  
;-------------
;MAIN.ASM
;-------------
.586
INCLUDE IOLIB.LIB

STACKS SEGMENT USE16 PARA STACK 'STACK'
	 DW 128 DUP(0)
TOPS LABEL WORD
STACKS ENDS

	EXTERN DISPLAY:FAR
	EXTERN GETINPUT:FAR
	PUBLIC BUF

DATAS SEGMENT USE16 PARA PUBLIC 'DATA'
BUF DB 21,22 DUP(' ')
CR	DB 13,10,'$'
DATAS ENDS

CODES SEGMENT USE16 PARA PUBLIC 'CODE'
	  ASSUME CS:CODES,DS:DATAS
START:MOV AX,DATAS
	  MOV DS,AX
	  LEA SP,TOPS
	  CALL FAR PTR GETINPUT
	  ;INOUT BUF,10
	  MOV BH,0
	  MOV BL,BUF+1
	  MOV BUF[2+BX],20H
	  INOUT CR,9
	  CALL FAR PTR DISPLAY
	  MOV AH,4CH
	  INT 21H
CODES ENDS
	END START
	  
	
```

